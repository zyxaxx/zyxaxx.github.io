<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笑笑</title>
  
  <subtitle>我永远喜欢笑笑</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-21T12:57:43.024Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>张祎鑫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小甲鱼三十课文件系统：介绍一个高大上的东西，课上习题＆课后作业</title>
    <link href="http://example.com/2021/04/21/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B8%89%E5%8D%81%E8%AF%BE%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%AB%98%E5%A4%A7%E4%B8%8A%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E8%AF%BE%E4%B8%8A%E4%B9%A0%E9%A2%98%EF%BC%86%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
    <id>http://example.com/2021/04/21/%E5%B0%8F%E7%94%B2%E9%B1%BC%E4%B8%89%E5%8D%81%E8%AF%BE%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%AB%98%E5%A4%A7%E4%B8%8A%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E8%AF%BE%E4%B8%8A%E4%B9%A0%E9%A2%98%EF%BC%86%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</id>
    <published>2021-04-21T11:34:14.950Z</published>
    <updated>2021-04-21T12:57:43.024Z</updated>
    
    <content type="html"><![CDATA[<p>•任务：将文件（record.txt）中的数据进行分割并按照以下规律保存起来：</p><p>–小甲鱼的对话单独保存为boy_*.txt的文件（去掉“小甲鱼:”）</p><p>–小客服的对话单独保存为girl_*.txt的文件（去掉“小客服:”）</p><p>–文件中总共有三段对话，分别保存为boy_1.txt, girl_1.txt，boy_2.txt, girl_2.txt, boy_3.txt, gril_3.txt共6个文件（提示：文件中不同的对话间已经使用“==========”分割）</p><p>基础方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p8_1.py</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">boy = []</span><br><span class="line">girl = []</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\HP\Desktop\源代码\源代码\p8\record2.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each_line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">if</span> each_line[:<span class="number">6</span>] != <span class="string">&#x27;======&#x27;</span>:</span><br><span class="line">        <span class="comment"># 用split切片函数分别把冒号前后的语句送入role，line_spoken</span></span><br><span class="line">        (role, line_spoken) = each_line.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> role == <span class="string">&#x27;小甲鱼&#x27;</span>:</span><br><span class="line">            boy.append(line_spoken)</span><br><span class="line">        <span class="keyword">if</span> role == <span class="string">&#x27;小客服&#x27;</span>:</span><br><span class="line">            girl.append(line_spoken)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        file_name_boy = <span class="string">&#x27;boy_&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">        file_name_girl = <span class="string">&#x27;girl_&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">        boy_file = <span class="built_in">open</span>(file_name_boy, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        girl_file = <span class="built_in">open</span>(file_name_girl, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        boy_file.writelines(boy)</span><br><span class="line">        girl_file.writelines(girl)</span><br><span class="line"></span><br><span class="line">        boy = []</span><br><span class="line">        girl = []</span><br><span class="line">        count += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">file_name_boy = <span class="string">&#x27;boy_&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">file_name_girl = <span class="string">&#x27;girl_&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">boy_file = <span class="built_in">open</span>((<span class="string">r&quot;C:\Users\HP\Desktop\源代码\源代码\p8\%s&quot;</span> % file_name_boy), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">girl_file = <span class="built_in">open</span>((<span class="string">r&quot;C:\Users\HP\Desktop\源代码\源代码\p8\%s&quot;</span> % file_name_girl), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">boy_file.writelines(boy)</span><br><span class="line">girl_file.writelines(girl)</span><br><span class="line"></span><br><span class="line">boy_file.close()</span><br><span class="line">girl_file.close()</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装成函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p8_2.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_file</span>(<span class="params">boy, girl, count</span>):</span></span><br><span class="line">    file_name_boy = <span class="string">&#x27;boy_&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">    file_name_girl = <span class="string">&#x27;girl_&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">    boy_file = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\goodb\Desktop\%s&quot;</span> % (file_name_boy), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    girl_file = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\goodb\Desktop\%s&quot;</span> % (file_name_girl), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    boy_file.writelines(boy)</span><br><span class="line">    girl_file.writelines(girl)</span><br><span class="line"></span><br><span class="line">    boy_file.close()</span><br><span class="line">    girl_file.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_file</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    boy = []</span><br><span class="line">    girl = []</span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">open</span>(file_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each_line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> each_line[:<span class="number">6</span>] != <span class="string">&#x27;======&#x27;</span>:</span><br><span class="line">            (role, line_spoken) = each_line.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> role == <span class="string">&#x27;小甲鱼&#x27;</span>:</span><br><span class="line">                boy.append(line_spoken)</span><br><span class="line">            <span class="keyword">if</span> role == <span class="string">&#x27;小客服&#x27;</span>:</span><br><span class="line">                girl.append(line_spoken)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            save_file(boy, girl, count)</span><br><span class="line"></span><br><span class="line">            boy = []</span><br><span class="line">            girl = []</span><br><span class="line">            count += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">    save_file(boy, girl, count)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">split_file(<span class="string">r&quot;C:\Users\goodb\Desktop\record.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>课后作业</p><h1 id="0-编写一个程序，统计当前目录下每个文件类型的文件数，程序实现如图："><a href="#0-编写一个程序，统计当前目录下每个文件类型的文件数，程序实现如图：" class="headerlink" title="0.编写一个程序，统计当前目录下每个文件类型的文件数，程序实现如图："></a>0.编写一个程序，统计当前目录下每个文件类型的文件数，程序实现如图：<img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210421200650.webp" alt="img"></h1><p>答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">all_files = os.listdir(os.curdir)  <span class="comment"># 使用os.curdir表示当前目录更标准</span></span><br><span class="line">type_dict = <span class="built_in">dict</span>()  <span class="comment"># 先定一个空字典来存放&#123;&#x27;后缀名&#x27;: 数量&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each_file <span class="keyword">in</span> all_files:</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(each_file):</span><br><span class="line">        type_dict.setdefault(<span class="string">&#x27;文件夹&#x27;</span>, <span class="number">0</span>)  <span class="comment"># 当原字典中无该键时，则新增该键和对于的值，并返回键值</span></span><br><span class="line">        type_dict[<span class="string">&#x27;文件夹&#x27;</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ext = os.path.splitext(each_file)[<span class="number">1</span>]  <span class="comment"># 返回的是元组，获取文件的后缀名=ext</span></span><br><span class="line">        type_dict.setdefault(ext, <span class="number">0</span>)</span><br><span class="line">        type_dict[ext] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each_type <span class="keyword">in</span> type_dict.keys():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;该文件夹下共有类型为【%s】的文件 %d 个&#x27;</span> % (each_type, type_dict[each_type]))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">该文件夹下共有类型为【文件夹】的文件 <span class="number">3</span> 个</span><br><span class="line">该文件夹下共有类型为【.png】的文件 <span class="number">1</span> 个</span><br><span class="line">该文件夹下共有类型为【.py】的文件 <span class="number">1</span> 个</span><br><span class="line">该文件夹下共有类型为【.lnk】的文件 <span class="number">14</span> 个</span><br><span class="line">该文件夹下共有类型为【.pptx】的文件 <span class="number">1</span> 个</span><br><span class="line">该文件夹下共有类型为【.ini】的文件 <span class="number">1</span> 个</span><br><span class="line">该文件夹下共有类型为【.exe】的文件 <span class="number">1</span> 个</span><br></pre></td></tr></table></figure><h1 id="1-编写一个程序，计算当前文件夹下所有文件的大小，程序实现如图："><a href="#1-编写一个程序，计算当前文件夹下所有文件的大小，程序实现如图：" class="headerlink" title="1. 编写一个程序，计算当前文件夹下所有文件的大小，程序实现如图："></a>1. 编写一个程序，计算当前文件夹下所有文件的大小，程序实现如图：</h1><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210421200741.webp" alt="img"></p><p>答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_size</span>():</span></span><br><span class="line">    file_name = os.listdir(os.curdir)</span><br><span class="line">    dict1 = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each_file <span class="keyword">in</span> file_name:</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(each_file):</span><br><span class="line">            dict1.setdefault(each_file, os.path.getsize(each_file))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s的大小为：【%d Bytes】&#x27;</span> % (each_file, dict1[each_file]))</span><br><span class="line"></span><br><span class="line">file_size()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111.</span>py的大小为：【<span class="number">1240</span> Bytes】</span><br><span class="line"><span class="number">1111.</span>py的大小为：【<span class="number">338</span> Bytes】</span><br></pre></td></tr></table></figure><h1 id="2-编写一个程序，用户输入文件名以及开始搜索的路径，搜索该文件是否存在。如遇到文件夹，则进入文件夹继续搜索，程序实现如图："><a href="#2-编写一个程序，用户输入文件名以及开始搜索的路径，搜索该文件是否存在。如遇到文件夹，则进入文件夹继续搜索，程序实现如图：" class="headerlink" title="2. 编写一个程序，用户输入文件名以及开始搜索的路径，搜索该文件是否存在。如遇到文件夹，则进入文件夹继续搜索，程序实现如图："></a>2. 编写一个程序，用户输入文件名以及开始搜索的路径，搜索该文件是否存在。如遇到文件夹，则进入文件夹继续搜索，程序实现如图：</h1><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210421203751.webp" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_file</span>(<span class="params">start_dir, target</span>):</span></span><br><span class="line">    os.chdir(start_dir)  <span class="comment"># 切换当前工作目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each_file <span class="keyword">in</span> os.listdir(os.curdir):</span><br><span class="line">        <span class="keyword">if</span> each_file == target:</span><br><span class="line">            <span class="built_in">print</span>(os.getcwd() + os.sep + each_file)  <span class="comment"># 使用os.sep使程序更标准</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(each_file):</span><br><span class="line">            search_file(each_file, target)  <span class="comment"># 递归调用</span></span><br><span class="line">            os.chdir(os.pardir)  <span class="comment"># 递归调用后切记返回上一层目录</span></span><br><span class="line"></span><br><span class="line">start_dir = <span class="built_in">input</span>(<span class="string">&#x27;请输入待查找的初始目录：&#x27;</span>)</span><br><span class="line">target = <span class="built_in">input</span>(<span class="string">&#x27;请输入需要查找的目标文件：&#x27;</span>)</span><br><span class="line">search_file(start_dir, target)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入待查找的初始目录：E:\\python</span><br><span class="line">请输入需要查找的目标文件：Linux基础.pdf</span><br><span class="line">E:\python\Linux基础.pdf</span><br><span class="line">E:\python\Python基础班\Python基础班资料\01-基础班-第01天&#123;Linux、以及命令&#125;\1-上课资料\pdf版\Linux基础.pdf</span><br></pre></td></tr></table></figure><ol start="3"><li>编写一个程序，用户输入开始搜索的路径，查找该路径下（包含子文件夹内）所有的视频格式文件（要求查找mp4, rmvb, avi的格式即可），并把创建一个文件（vedioList.txt）存放所有找到的文件的路径，程序实现如图：</li></ol><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210421205536.webp" alt="img"></p><p>答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">vedio_list = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_file</span>(<span class="params">start_dir</span>):</span></span><br><span class="line">    os.chdir(start_dir)</span><br><span class="line">    <span class="keyword">for</span> each_file <span class="keyword">in</span> os.listdir(os.curdir):</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(each_file):</span><br><span class="line">            file_ext = os.path.splitext(each_file)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> file_ext <span class="keyword">in</span> [<span class="string">&#x27;.mp4&#x27;</span>, <span class="string">&#x27;.rmvb&#x27;</span>, <span class="string">&#x27;.avi&#x27;</span>]:</span><br><span class="line">                vedio_list.append(os.getcwd() + os.sep + each_file + os.linesep)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(each_file):</span><br><span class="line">            search_file(each_file)  <span class="comment"># 递归调用</span></span><br><span class="line">            os.chdir(os.pardir)  <span class="comment"># 递归调用后切记返回上一层目录</span></span><br><span class="line">    <span class="keyword">return</span> vedio_list</span><br><span class="line"></span><br><span class="line">start_dir = <span class="built_in">input</span>(<span class="string">&#x27;请输入待查找的初始目录：&#x27;</span>)</span><br><span class="line">vedio_list = search_file(start_dir)</span><br><span class="line">f = <span class="built_in">open</span>(os.getcwd() + os.sep + <span class="string">&#x27;VedioList.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.writelines(vedio_list)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\<span class="number">123</span>\<span class="number">111</span>.mp4</span><br><span class="line">E:\<span class="number">123</span>\<span class="number">1111</span>\<span class="number">123</span>.avi</span><br><span class="line">E:\<span class="number">123</span>\<span class="number">112</span>\<span class="number">1234</span>\weq.rmvb</span><br></pre></td></tr></table></figure><ol start="4"><li>编写一个程序，用户输入关键字，查找当前文件夹内（如果当前文件夹内包含文件夹，则进入文件夹继续搜索）所有含有该关键字的文本文件（.txt后缀），要求显示该文件所在的位置以及关键字在文件中的具体位置（第几行第几个字符），程序实现如图：</li></ol><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210421205621.webp" alt="img"></p><p>答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_pos</span>(<span class="params">key_dict</span>):</span>  <span class="comment"># 负责打印</span></span><br><span class="line">    keys = key_dict.keys()</span><br><span class="line">    keys = <span class="built_in">sorted</span>(keys)  <span class="comment"># 由于字典是无序的，我们这里对行数进行排序</span></span><br><span class="line">    <span class="keyword">for</span> each_key <span class="keyword">in</span> keys:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;关键字出现在第 %s 行，第 %s 个位置。&#x27;</span> % (each_key, <span class="built_in">str</span>(key_dict[each_key])))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pos_in_line</span>(<span class="params">line, key</span>):</span></span><br><span class="line">    pos = []</span><br><span class="line">    begin = line.find(key)</span><br><span class="line">    <span class="keyword">while</span> begin != -<span class="number">1</span>:</span><br><span class="line">        pos.append(begin + <span class="number">1</span>)  <span class="comment"># 用户的角度是从1开始数</span></span><br><span class="line">        begin = line.find(key, begin + <span class="number">1</span>)  <span class="comment"># 从下一个位置继续查找</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_in_file</span>(<span class="params">file_name, key</span>):</span></span><br><span class="line">    f = <span class="built_in">open</span>(file_name)</span><br><span class="line">    count = <span class="number">0</span>  <span class="comment"># 记录行数</span></span><br><span class="line">    key_dict = <span class="built_in">dict</span>()  <span class="comment"># 字典，用户存放key所在具体行数对应具体位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each_line <span class="keyword">in</span> f:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> each_line:</span><br><span class="line">            pos = pos_in_line(each_line, key)  <span class="comment"># key在每行对应的位置</span></span><br><span class="line">            key_dict[count] = pos</span><br><span class="line"></span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> key_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_files</span>(<span class="params">key, detail</span>):</span></span><br><span class="line">    all_files = os.walk(os.getcwd())</span><br><span class="line">    txt_files = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> all_files:</span><br><span class="line">        <span class="keyword">for</span> each_file <span class="keyword">in</span> i[<span class="number">2</span>]:</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(each_file)[<span class="number">1</span>] == <span class="string">&#x27;.txt&#x27;</span>:  <span class="comment"># 根据后缀判断是否文本文件</span></span><br><span class="line">                each_file = os.path.join(i[<span class="number">0</span>], each_file)</span><br><span class="line">                txt_files.append(each_file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each_txt_file <span class="keyword">in</span> txt_files:</span><br><span class="line">        key_dict = search_in_file(each_txt_file, key)</span><br><span class="line">        <span class="keyword">if</span> key_dict:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;================================================================&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;在文件【%s】中找到关键字【%s】&#x27;</span> % (each_txt_file, key))</span><br><span class="line">            <span class="keyword">if</span> detail <span class="keyword">in</span> [<span class="string">&#x27;YES&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]:</span><br><span class="line">                print_pos(key_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="built_in">input</span>(<span class="string">&#x27;请将该脚本放于待查找的文件夹内，请输入关键字：&#x27;</span>)</span><br><span class="line">detail = <span class="built_in">input</span>(<span class="string">&#x27;请问是否需要打印关键字【%s】在文件中的具体位置（YES/NO）：&#x27;</span> % key)</span><br><span class="line">search_files(key, detail)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请将该脚本放于待查找的文件夹内，请输入关键字：Linux</span><br><span class="line">请问是否需要打印关键字【Linux】在文件中的具体位置（<span class="literal">YES</span>/<span class="literal">NO</span>）：y</span><br><span class="line">================================================================</span><br><span class="line">在文件【E:\python\study\<span class="number">312</span>\<span class="number">121.</span>txt】中找到关键字【Linux】</span><br><span class="line">关键字出现在第 <span class="number">1</span> 行，第 [<span class="number">6</span>, <span class="number">16</span>] 个位置。</span><br><span class="line">关键字出现在第 <span class="number">2</span> 行，第 [<span class="number">3</span>] 个位置。</span><br><span class="line">关键字出现在第 <span class="number">3</span> 行，第 [<span class="number">7</span>] 个位置。</span><br></pre></td></tr></table></figure><h1 id="5-请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！"><a href="#5-请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！" class="headerlink" title="5.请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！"></a>5.请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！</h1><ul><li>OS模块中关于文件/目录常用的函数使用方法</li></ul><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>getcwd()</td><td>返回当前工作目录</td></tr><tr><td>chdir()</td><td>改变工作目录</td></tr><tr><td>listdir(path=’.’)</td><td>列举指定目录中的文件名（’.’表示当前目录，’..’表示上一级目录）</td></tr><tr><td>mkdir(path)</td><td>创建单层目录，如果目录已存在抛出异常</td></tr><tr><td>makedirs(path)</td><td>递归创建多层目录，如果该目录已存在则抛出异常，注意：’E:\a\b’和’E:\a\c’并不会冲突）</td></tr><tr><td>remove(path)</td><td>删除文件</td></tr><tr><td>rmdir(path)</td><td>删除单层目录，如果该目录非空则抛出异常</td></tr><tr><td>removedirs(path)</td><td>递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常</td></tr><tr><td>rename(old,new)</td><td>将文件old重命名为new</td></tr><tr><td>system(command)</td><td>运行系统的shell命令</td></tr><tr><td>walk(top)</td><td>遍历top参数指定路径下的所有子目录，并将结果返回一个三元组（路径，[目录]，[文件]）</td></tr></tbody></table><p>以下是支持路径操作中常用到的一些定义，支持所有平台</p><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>os.curdir</td><td>指代当前目录</td></tr><tr><td>os.pardir</td><td>指代上一级目录</td></tr><tr><td>os.sep</td><td>输出操作系统特定的路径分隔符（在Windows下为’&#39;，Linux下为’/‘）</td></tr><tr><td>os.linesep</td><td>当前平台使用的行终止符（在Windows下为’\r\n’，Linux下为’\n’）</td></tr><tr><td>os.name</td><td>指代当前使用的操作系统（包括’posix’、’nt’、’mac’、’os2’、’ce’、’java’）</td></tr></tbody></table><ul><li>os.path模块中关于路径常用的函数使用办法</li></ul><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>basename(path)</td><td>去掉目录路径，单独返回文件名</td></tr><tr><td>dirname(path)</td><td>去掉文件名，单独返回目录路径</td></tr><tr><td>join(path1[,path2[,…]])</td><td>将path1和path2各部分组合成一个路径名</td></tr><tr><td>split(path)</td><td>分割文件名和路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在</td></tr><tr><td>splitext(path)</td><td>分离文件名和扩展名，返回(f_name, f_extension)元组。</td></tr><tr><td>getsize(file)</td><td>返回指定文件的尺寸，单位是字节</td></tr><tr><td>getatime(file)</td><td>返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td></tr><tr><td>getctime(file)</td><td>返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td></tr><tr><td>getmtime(file)</td><td>返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td></tr></tbody></table><p>以下为函数返回True或False</p><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>exists(path)</td><td>判断指定路径（目录或文件）是否存在</td></tr><tr><td>isabs(path)</td><td>判断指定路径是否为绝对路径</td></tr><tr><td>isdir(path)</td><td>判断指定路径是否存在且是一个目录</td></tr><tr><td>isfile(path)</td><td>判断指定路径是否存在且是一个文件</td></tr><tr><td>islink(path)</td><td>判断指定路径是否存在且是一个符号链接</td></tr><tr><td>ismount(path)</td><td>判断指定路径是否存在且是一个挂载点</td></tr><tr><td>samefile(path1,path2)</td><td>判断path1和path2两个路径是否指向同一个文件</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">第八章文件</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python小甲鱼第二十八课：文件：因为懂你，所以更永恒</title>
    <link href="http://example.com/2021/04/20/Python%E5%B0%8F%E7%94%B2%E9%B1%BC/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%96%87%E4%BB%B6%EF%BC%9A%E5%9B%A0%E4%B8%BA%E6%87%82%E4%BD%A0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9B%B4%E6%B0%B8%E6%81%92/"/>
    <id>http://example.com/2021/04/20/Python%E5%B0%8F%E7%94%B2%E9%B1%BC/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%96%87%E4%BB%B6%EF%BC%9A%E5%9B%A0%E4%B8%BA%E6%87%82%E4%BD%A0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9B%B4%E6%B0%B8%E6%81%92/</id>
    <published>2021-04-20T09:42:20.841Z</published>
    <updated>2021-04-20T10:04:40.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-下边只有一种方式不能打开文件，请问是哪一种，为什么？"><a href="#0-下边只有一种方式不能打开文件，请问是哪一种，为什么？" class="headerlink" title="0.  下边只有一种方式不能打开文件，请问是哪一种，为什么？"></a>0.  下边只有一种方式不能打开文件，请问是哪一种，为什么？</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;E:/test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="comment">#A</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;E:\test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="comment">#B</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;E://test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="comment">#C</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;E:\\test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="comment">#D</span></span><br></pre></td></tr></table></figure><p>答：B不能打开文件。<br> Windows在路径名中既可以接受斜线（/）也可以接受反斜线（\），不过如果使用反斜线作为路径名的分隔符的话，要注意使用双<br> 行转义，否则Python会将反斜线进行转义，例如（\n）看成一个换行符，（\t）看作一个制表符等。</p><h1 id="1-打开一个文件我们使用open-函数，通过设置文件的打开模式，决定打开的文件具有那些性质，请问默认的打开模式是什么呢？"><a href="#1-打开一个文件我们使用open-函数，通过设置文件的打开模式，决定打开的文件具有那些性质，请问默认的打开模式是什么呢？" class="headerlink" title="1.  打开一个文件我们使用open()函数，通过设置文件的打开模式，决定打开的文件具有那些性质，请问默认的打开模式是什么呢？"></a>1.  打开一个文件我们使用open()函数，通过设置文件的打开模式，决定打开的文件具有那些性质，请问默认的打开模式是什么呢？</h1><p>答：open()函数默认的打开模式是’ rt’，即可读、文本的模式打开。</p><hr><h1 id="2-请问-gt-gt-gt-open-‘-E-Test-bin’-‘-xb’-是以什么样的模式打开文件的？"><a href="#2-请问-gt-gt-gt-open-‘-E-Test-bin’-‘-xb’-是以什么样的模式打开文件的？" class="headerlink" title="2.  请问 &gt;&gt;&gt; open(‘ E: \Test.bin’ ,  ‘ xb’ ) 是以什么样的模式打开文件的？"></a>2.  请问 &gt;&gt;&gt; open(‘ E: \Test.bin’ ,  ‘ xb’ ) 是以什么样的模式打开文件的？</h1><p>答：以“可写入以及二进制模式”打来文件“E:\Test.bin”。<br> 这里要注意的是’ x’和’ w’均是以“可写入”的模式打开文件，但以’ x’模式打开的时候，如果路径下已经存在相同的文件名，会抛出异常，而’w’模式的话会直接覆盖同名文件。<br> 因此，’ w’模式打开文件会比较危险，容易导致此前的内容遗失，因此使用’ w’模式打开文件前先检查该文件名是否已经存在显得非常重要！下节课小甲鱼会教你如何安全的打开一个文件。</p><hr><h1 id="3-尽管Python有所谓的“垃圾回收机制”，但对于打开了的文件，在不需要用到的时候我们仍然使用f-close-将文件对象“关闭”，这是为什么呢？"><a href="#3-尽管Python有所谓的“垃圾回收机制”，但对于打开了的文件，在不需要用到的时候我们仍然使用f-close-将文件对象“关闭”，这是为什么呢？" class="headerlink" title="3.尽管Python有所谓的“垃圾回收机制”，但对于打开了的文件，在不需要用到的时候我们仍然使用f. close()将文件对象“关闭”，这是为什么呢？"></a>3.尽管Python有所谓的“垃圾回收机制”，但对于打开了的文件，在不需要用到的时候我们仍然使用f. close()将文件对象“关闭”，这是为什么呢？</h1><p>答：Python拥有垃圾收集机制，会在文件对象的引用计数降至零的时候自动关闭文件，所以在Python编程里，如果忘记关闭文件并不会带来什么危险。<br> 但并不是说就可以不要关闭文件，如果你对文件进行了写入操作，那么你应该在完成写入之后进行关闭文件。因为Python可能会缓存你写入文件中的数据，如果这中间断电了神马的，那些缓存的数据根本就不会写入到文件中。所以，为了安全起见，要养成使用完文件后立刻关闭的优雅习惯。</p><hr><h1 id="4-如何将一个文件对象（f）中的数据存放进列表中？"><a href="#4-如何将一个文件对象（f）中的数据存放进列表中？" class="headerlink" title="4.  如何将一个文件对象（f）中的数据存放进列表中？"></a>4.  如何将一个文件对象（f）中的数据存放进列表中？</h1><p>答：list(f)即可。</p><hr><h1 id="5-如何迭代打印出文件对象（f）中的每一行数据？"><a href="#5-如何迭代打印出文件对象（f）中的每一行数据？" class="headerlink" title="5.  如何迭代打印出文件对象（f）中的每一行数据？"></a>5.  如何迭代打印出文件对象（f）中的每一行数据？</h1><p>答：直接使用for语句把文件对象迭代出来即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> each_line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(each_line)</span><br></pre></td></tr></table></figure><hr><h1 id="6-文件对象的内置方法f-read-size-1-作用是读取文件对象内容，size参数是可选的，那如果设置了size-10，例如f-read-10-，将返回什么？"><a href="#6-文件对象的内置方法f-read-size-1-作用是读取文件对象内容，size参数是可选的，那如果设置了size-10，例如f-read-10-，将返回什么？" class="headerlink" title="6.  文件对象的内置方法f. read([size=-1])作用是读取文件对象内容，size参数是可选的，那如果设置了size=10，例如f. read(10)，将返回什么？"></a>6.  文件对象的内置方法f. read([size=-1])作用是读取文件对象内容，size参数是可选的，那如果设置了size=10，例如f. read(10)，将返回什么？</h1><p>答：将返回从文件指针开始**$\textcolor{red}{(注意这里并不是文件头哦)} $**的连续10个字符。</p><hr><h1 id="7-如何获得文件对象（f）当前文件指针的位置？"><a href="#7-如何获得文件对象（f）当前文件指针的位置？" class="headerlink" title="7.如何获得文件对象（f）当前文件指针的位置？"></a>7.如何获得文件对象（f）当前文件指针的位置？</h1><p>答：f.tell()即可。</p><hr><h1 id="8-还是视频中的那个演示文件（record-txt），请问为何f-seek-45-0-不会出错，但f-seek-46-就出错了呢？"><a href="#8-还是视频中的那个演示文件（record-txt），请问为何f-seek-45-0-不会出错，但f-seek-46-就出错了呢？" class="headerlink" title="8.  还是视频中的那个演示文件（record. txt），请问为何f. seek(45,  0)不会出错，但f. seek(46)就出错了呢？"></a>8.  还是视频中的那个演示文件（record. txt），请问为何f. seek(45,  0)不会出错，但f. seek(46)就出错了呢？</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">46</span>)</span><br><span class="line"><span class="number">46</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    Flie <span class="string">&quot;&lt;pyshell#18&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        f.readline()</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;gbk&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xe3 in possition 4:illegal multibyte sequence</span></span><br></pre></td></tr></table></figure><p>答：因为使用f. seek()定位的文件指针是按字节为单位进行计算的，演示文件（record. txt）是以GBK进行编码的，按照规则，一个汉字需要两个字节，f. seek(45)的位置位于字符“小”的开始位置，因此可以正常打印，而f. seek(46)的位置刚好位于字符“小”的中间位置，因此按照GBK的编码规则将无法将其解码！</p><hr><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h1 id="0-试尝试将文件（OpenMe-mp3）打印到屏幕上。"><a href="#0-试尝试将文件（OpenMe-mp3）打印到屏幕上。" class="headerlink" title="0.试尝试将文件（OpenMe.mp3）打印到屏幕上。"></a>0.试尝试将文件（<a href="https://pan.baidu.com/s/1WyIaK3hVjYKj3PKymlt8iw">OpenMe.mp3</a>）打印到屏幕上。</h1><p>答：直接使用打开文本文件的形式打开即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;OpenMe.mp3&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> each_line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(each_line , end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">长期使用Windows操作系统的朋友很容易被扩展名所误导，认为扩展名决定文件类型，其实这种观念是错误的！</span><br><span class="line"></span><br><span class="line">其实这就跟一个姓张的坏人，尽管把名字改为了“张好人”，但他还是一个坏人是一个道理的^_^</span><br><span class="line"></span><br><span class="line">关于文件的扩展名，初学者容易走进的误区：</span><br><span class="line"></span><br><span class="line">误区一：文件扩展名是一个文件的必要构成部分</span><br><span class="line"></span><br><span class="line">一个文件可以有或没有扩展名，对于打开文件操作，没有扩展名的文件需要选择程序去打开它，有扩展名的文件会自动用设置好的程序（如有）去尝试打开（是“尝试打开”，而不是“打开”的原因参看下面的第<span class="number">2</span>个误区），文件扩展名是一个常规文件的构成部分，但一个文件并不一定需要一个扩展名。</span><br><span class="line"></span><br><span class="line">误区二：文件扩展名表明了该文件是何种类型</span><br><span class="line"></span><br><span class="line">文件扩展名可以人为设定，扩展名为TXT的文件有可能是一张图片，同样，扩展名为M-P3的文件，依然可能是一个视频。</span><br></pre></td></tr></table></figure><hr><h1 id="1-编写代码，将上一题中的文件（OpenMe-mp3）保存为新文件（OpenMe-txt）"><a href="#1-编写代码，将上一题中的文件（OpenMe-mp3）保存为新文件（OpenMe-txt）" class="headerlink" title="1.  编写代码，将上一题中的文件（OpenMe.mp3）保存为新文件（OpenMe. txt）"></a>1.  编写代码，将上一题中的文件（OpenMe.mp3）保存为新文件（OpenMe. txt）</h1><p>答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方法：</span></span><br><span class="line">f1 = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Python\Python3\OpenMe.mp3&#x27;</span>)</span><br><span class="line">f2 = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Python\Python3\OpenMe.txt&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> each_line <span class="keyword">in</span> f1:</span><br><span class="line">    f2.write(each_line)</span><br><span class="line">f1.close()</span><br><span class="line">f2.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方法</span></span><br><span class="line">f1 = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Python\Python3\OpenMe.mp3&#x27;</span>)</span><br><span class="line">f2 = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Python\Python3\OpenMe2.txt&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">f2.write(f1.read())</span><br><span class="line">f1.close()</span><br><span class="line">f2.close() </span><br></pre></td></tr></table></figure><hr><h1 id="2-请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！"><a href="#2-请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！" class="headerlink" title="2.请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！"></a>2.请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！</h1><ul><li>利用help(open)可以看到open()函数的定义：open(file,mode=’r’,buffering=1,encoding=None,errors=None,newline=None,closefd=True,opener=None)<br> 默认打开模式是’rt’，也就是只读和文本模式。</li></ul><table><thead><tr><th>打开模式</th><th>执行操作</th></tr></thead><tbody><tr><td>‘r’</td><td>以只读方式打开文件（默认）</td></tr><tr><td>‘w’</td><td>以写入的方式打开文件，会覆盖已存在的文件（有风险**）</td></tr><tr><td>‘x’</td><td>如果文件已经存在，使用此模式打开将引发异常</td></tr><tr><td>‘a’</td><td>以写入模式打开，如果文件存在，则在末尾追加写入</td></tr><tr><td>‘b’</td><td>以二进制模式打开文件</td></tr><tr><td>‘t’</td><td>以文本模式打开（默认）</td></tr><tr><td>‘+’</td><td>可读写模式（可添加到其他模式中使用）</td></tr><tr><td>‘U’</td><td>通用换行符支持</td></tr></tbody></table><ul><li>文件对象的方法</li></ul><table><thead><tr><th>文件对象的方法</th><th align="left">执行操作</th></tr></thead><tbody><tr><td>close()</td><td align="left">关闭文件</td></tr><tr><td>read(size=-1)</td><td align="left">从文件读取size个字符（单位是字节，中文算2个字节），当未给定size或给定负值的时候，读取剩余的所有字符，然后作为字符串返回（注意这里的读取是从文件指针开始读取，而不是从初始位置）</td></tr><tr><td>readline()</td><td align="left">从文件中读取一整行字符串（包括末尾的换行’\n’）</td></tr><tr><td>write(str)</td><td align="left">将字符串str写入文件</td></tr><tr><td>writelines(seq)</td><td align="left">向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象</td></tr><tr><td>seek(offset, from)</td><td align="left">在文件中移动文件指针，从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节</td></tr><tr><td>tell()</td><td align="left">返回当前文件指针在文件中的位置</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;D:\Python\Python3\c.txt&quot;</span>, <span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件名为: &quot;</span>, fo.name)</span><br><span class="line">seq = [<span class="string">&quot;菜鸟教程 1\n&quot;</span>, <span class="string">&quot;菜鸟教程 2&quot;</span>]</span><br><span class="line">fo.writelines( seq )  </span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">fo.close()</span><br><span class="line"><span class="comment"># 输出就是写入以下内容到c.txt中：</span></span><br><span class="line">菜鸟教程 <span class="number">1</span></span><br><span class="line">菜鸟教程 <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-下边只有一种方式不能打开文件，请问是哪一种，为什么？&quot;&gt;&lt;a href=&quot;#0-下边只有一种方式不能打开文件，请问是哪一种，为什么？&quot; class=&quot;headerlink&quot; title=&quot;0.  下边只有一种方式不能打开文件，请问是哪一种，为什么？&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="Python学习" scheme="http://example.com/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python小甲鱼第二十七课：集合：在我的世界里，你就是唯一</title>
    <link href="http://example.com/2021/04/20/Python%E5%B0%8F%E7%94%B2%E9%B1%BC/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%9A%E9%9B%86%E5%90%88%EF%BC%9A%E5%9C%A8%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E9%87%8C%EF%BC%8C%E4%BD%A0%E5%B0%B1%E6%98%AF%E5%94%AF%E4%B8%80/"/>
    <id>http://example.com/2021/04/20/Python%E5%B0%8F%E7%94%B2%E9%B1%BC/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%9A%E9%9B%86%E5%90%88%EF%BC%9A%E5%9C%A8%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E9%87%8C%EF%BC%8C%E4%BD%A0%E5%B0%B1%E6%98%AF%E5%94%AF%E4%B8%80/</id>
    <published>2021-04-20T08:20:23.655Z</published>
    <updated>2021-04-20T08:50:23.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-请问集合的唯一作用是什么呢？"><a href="#0-请问集合的唯一作用是什么呢？" class="headerlink" title="0.请问集合的唯一作用是什么呢？"></a>0.请问集合的唯一作用是什么呢？</h1><p>答：集合几乎所有的作用就是确保里边包含的元素的唯一性，就像世界上没有两片完全相同的树叶一样，集合内不可能存在两个相同的元素！</p><hr><h1 id="1-如果你希望创建的集合是不变的，应该怎么做？"><a href="#1-如果你希望创建的集合是不变的，应该怎么做？" class="headerlink" title="1. 如果你希望创建的集合是不变的，应该怎么做？"></a>1. 如果你希望创建的集合是不变的，应该怎么做？</h1><p>答：frozenset()</p><hr><h1 id="2-请问如何确定一个集合里边有多少个元素？"><a href="#2-请问如何确定一个集合里边有多少个元素？" class="headerlink" title="2. 请问如何确定一个集合里边有多少个元素？"></a>2. 请问如何确定一个集合里边有多少个元素？</h1><p>答：没错，len()函数正好可以满足你此刻的需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_set = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(num_set)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">set</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">len</span>(<span class="params">num_set</span>)</span></span><br><span class="line"><span class="class">5</span></span><br></pre></td></tr></table></figure><h1 id="3-请目测以下代码会打印什么内容？"><a href="#3-请目测以下代码会打印什么内容？" class="headerlink" title="3. 请目测以下代码会打印什么内容？"></a>3. 请目测以下代码会打印什么内容？</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_set = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_set[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>答：会报错，因为集合是无序的。<code>TypeError: &#39;set&#39; object does not support indexing</code></p><h1 id="4-请问-set1-1-2-和-set1-set-1-2-执行的结果一样吗？"><a href="#4-请问-set1-1-2-和-set1-set-1-2-执行的结果一样吗？" class="headerlink" title="4. 请问 set1 = {[1, 2]} 和 set1 = set([1, 2]) 执行的结果一样吗？"></a>4. 请问 set1 = {[1, 2]} 和 set1 = set([1, 2]) 执行的结果一样吗？</h1><p>答：不一样，set1 = set([1, 2]) 会生成一个集合{1, 2}，但set1 = {[1, 2]}却会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 = &#123;[<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#7&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    set1 = &#123;[<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(set1)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">set</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">set1</span>)</span></span><br><span class="line">&#123;1, 2&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>从报错信息上我们看到“列表不是可哈希类型”，没错，列表是可变的，它怎么可以哈希呢？！咦，等等，这句话好像<br> 在那听过……呃，敢情集合跟字典的存储方式一样的丫！<br> 其实你再想想就会觉得很有道理，利用哈希函数计算，相同的元素得到的哈希值（存放地址）是相同的，所以在集合中<br> 所有相同的元素都会覆盖掉，因此有了集合的唯一性。<br> 然后你继续接着想就觉得更有道理了，通过哈希函数计算的地址不可能是按顺序排放的，所以集合才强调是无序的！</p><h1 id="5-打开你的IDLE，输入set1-1-1-0-，你发现了什么？"><a href="#5-打开你的IDLE，输入set1-1-1-0-，你发现了什么？" class="headerlink" title="5. 打开你的IDLE，输入set1 = {1, 1.0}，你发现了什么？"></a>5. 打开你的IDLE，输入set1 = {1, 1.0}，你发现了什么？</h1><p>答：没错， 集合内容是{1.0}，其实你弄懂了上一题，这一题一样容易：因为在Python的哈希函数会将相同的值的元素计算得到相同的地址，所以1和1.0是等值的。</p><h1 id="6-请问如何给集合添加和删除元素？"><a href="#6-请问如何给集合添加和删除元素？" class="headerlink" title="6. 请问如何给集合添加和删除元素？"></a>6. 请问如何给集合添加和删除元素？</h1><p>答：使用add()方法可以为集合添加元素，使用remove()方法可以删除集合中已知的元素。</p><hr><h1 id="7-请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！"><a href="#7-请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！" class="headerlink" title="7.请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！"></a>7.请写下这一节课你学习到的内容：格式不限，回忆并复述是加强记忆的好方式！</h1><ul><li>集合的创建 set1 = {1,2,3,4,5}，注意，集合中重复的元素会被自动剔除。</li><li>集合是无序的，不支持索引。</li><li>可以利用工厂函数set()来创建一个集合：set2 = set([1,2,3,4,5])</li><li>如何访问集合中的值：<br> for语句进行遍历 ；in/not in 判断是否在集合中；add()添加；remove()移除</li><li>不可变集合：用frozenset()来创建，其不可添加元素也不可移除已有元素。</li></ul><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420164818.webp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-请问集合的唯一作用是什么呢？&quot;&gt;&lt;a href=&quot;#0-请问集合的唯一作用是什么呢？&quot; class=&quot;headerlink&quot; title=&quot;0.请问集合的唯一作用是什么呢？&quot;&gt;&lt;/a&gt;0.请问集合的唯一作用是什么呢？&lt;/h1&gt;&lt;p&gt;答：集合几乎所有的作用就是确</summary>
      
    
    
    
    
    <category term="Python学习" scheme="http://example.com/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>An online multi-channel SSVEP-based brain–computer interface using a anonical correlation analysis method</title>
    <link href="http://example.com/2021/04/20/%E5%9F%BA%E4%BA%8E%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%A4%9A%E9%80%9A%E9%81%93SSVEP%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2021/04/20/%E5%9F%BA%E4%BA%8E%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%A4%9A%E9%80%9A%E9%81%93SSVEP%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-04-20T03:36:36.710Z</published>
    <updated>2021-04-21T13:02:28.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-总结"><a href="#0-总结" class="headerlink" title="0. 总结"></a>0. 总结</h2><h2 id="1-研究目标"><a href="#1-研究目标" class="headerlink" title="1. 研究目标"></a>1. 研究目标</h2><h2 id="2-研究背景及问题陈述"><a href="#2-研究背景及问题陈述" class="headerlink" title="2. 研究背景及问题陈述"></a>2. 研究背景及问题陈述</h2><p>近年来，稳态视觉诱发电位(SSVEP)在脑机接口(BCI)系统中的应用受到越来越多的关注。然而，当前基于SSVEP的BCI系统的几个方面需要改进，特别是在速度、用户变化和易用性方面。考虑到这些改进，本文提出了一种基于典型相关分析(CCA)方法提取与SSVEP相关的频率信息的在线多通道SSVEP脑机接口系统。利用离线数据对通道位置、窗口长度和谐波个数等关键参数进行了研究，并将结果用于指导在线系统的设计。基于SSVEP的脑机接口系统有6个目标，使用枕叶和顶叶的9个通道位置，窗口长度为2s，一次谐波，对12名受试者进行在线测试。结果表明，该系统具有较高的性能，平均准确率为95.3%，信息传输速率为58±9.6$bit min^{−1}$。该系统的优点是不需要信道选择和参数优化，可以利用谐波频率，用户变化小，易于设置。</p><p>SSVEP是对以高于6 Hz的频率调制的视觉刺激的周期性反应[4]。它与视觉刺激的基频相同，其谐波也相同。SSVEP可以从视觉皮层上方的头皮表面记录到。</p><p>近年来，在脑-机接口系统中使用SSVEP越来越引起人们的兴趣[5-10，18-21]。在基于SSVEP的脑机接口系统中，多个不同频率编码的刺激出现在视野中。通过将我们的兴趣或注意力转移到一系列频率编码刺激中的一种，可以产生不同的SSVEP。与其他BCI系统相比，基于SSVEP的BCI具有许多优点，包括更高的信噪比(SNR)和信息传输率(ITR)。此外，由于SSVEP是大脑的一种固有反应，因此只需要很少的训练就能使一个人操作BCI。基于SSVEP的脑-机接口的这些优点使其成为脑-机接口应用中一种很有前途的选择。但是，以前的基于SSVP的脑机接口系统在速度、用户多样性和易用性等方面都有待改进。</p><p>本人注：与前一篇<a href="https://zyxaxx.github.io/2021/04/14/%E5%9F%BA%E4%BA%8E%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E4%BA%8ESSVEP%E7%9A%84BCI%E9%A2%91%E7%8E%87%E8%AF%86%E5%88%AB/">Frequency Recognition Based on Canonical Correlation Analysis for SSVEP-Based BCIs</a> 的文章（出自同一实验室）相比，分析了多通道。<br>         本文提出了一种基于SSVEP的在线六目标脑-机接口。采用不需要通道位置选择和参数优化的CCA方法从多通道脑电信号中提取频率信息，并使用LCD监视器作为刺激。在线测试表明，本文提出的脑机接口系统具有较强的实用性和较高的性能。</p><h2 id="3-研究方法"><a href="#3-研究方法" class="headerlink" title="3. 研究方法"></a>3. 研究方法</h2><p>基于SSVEP的脑-机接口中的CCA方法</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420152918.png" alt="image-20210420152918274"></p><p>图1.CCA在EEG信号分析中的用法说明。X为多通道EEG信号。$Y_F$是具有f Hz刺激频率的参考信号。</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420153218.png" alt="image-20210420153218411"></p><p>ρ相对于Wx和Wy的最大值是最大典型相关。在Wx和Wy上的投影，即x和y，称为正则变体。</p><p>Lin等人[11]首先提出了使用CCA方法进行多通道SSVEP检测。我们的系统也采用了类似的方法。图1说明了CCA在基于SSVEP的BCI的频率识别中的使用，其中有K个目标，刺激频率分别为f1、f2、…、fk。X是指NTS长的多通道EEG信号的集合，而参考性$Y_f$是指与X具有相同长度的参考信号的集合。参考信号$Y_f$被设置为</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420153514.png" alt="image-20210420153514505"></p><p>其中$N_h$是谐波的数量。多通道EEG信号和每个参考信号被用作CCA方法的输入。输出的典型相关ρ可用于频率识别。</p><p>用户的命令C被识别为</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420154129.png" alt="image-20210420154129807"></p><p>其中$ρ_i$是以参考信号的频率为f1、f2、…、fk获得的CCA系数。</p><h2 id="4-评估，实验"><a href="#4-评估，实验" class="headerlink" title="4. 评估，实验"></a>4. 评估，实验</h2><p>在基于SSVEP的脑机接口系统中，有三个重要参数：<strong>信道位置、窗口长度T和谐波个数$N_H$<strong>。</strong>离线分析的目的是研究这三个参数对所提出的脑机接口系统性能的影响。</strong></p><p>离线数据来自清华大学的EEG数据库。该数据库是为算法研究而建立的。这些数据来自6名视力正常或矫正视力正常的健康右撇子成年人。受试者坐在一张舒适的椅子上，在一个屏蔽的录音室里。6个正方形发光二极管(LED)分别以13 Hz、14 Hz、15 Hz、16 Hz、17 Hz和18 Hz(即K=6)的频率闪烁，起到视觉刺激器的作用。LED的亮度由方波调制。每个受试者进行6次试验运行，其间休息3次。在每次运行中，受试者被要求注视6个LED的每一个8秒。因此，每个受试者在每个刺激频率下都获得了6段8秒的数据。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><h2 id="6-笔记"><a href="#6-笔记" class="headerlink" title="6. 笔记"></a>6. 笔记</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
    <summary type="html">基于典型相关分析的在线多通道SSVEP脑机接口(2009年5月6日)</summary>
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="CCA" scheme="http://example.com/tags/CCA/"/>
    
    <category term="SSVEP" scheme="http://example.com/tags/SSVEP/"/>
    
  </entry>
  
  <entry>
    <title>A high-speed BCI based on code modulation VEP</title>
    <link href="http://example.com/2021/04/15/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BC%96%E7%A0%81%E8%B0%83%E5%88%B6VEP%E7%9A%84%E9%AB%98%E9%80%9F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2021/04/15/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BC%96%E7%A0%81%E8%B0%83%E5%88%B6VEP%E7%9A%84%E9%AB%98%E9%80%9F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-04-15T09:22:35.425Z</published>
    <updated>2021-04-20T02:32:05.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-总结"><a href="#0-总结" class="headerlink" title="0. 总结"></a>0. 总结</h2><p>写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。注：写文章summary切记需要通过自己的思考，用自己的语言描述。忌讳直接Ctrl + c原文。</p><h2 id="1-研究目标"><a href="#1-研究目标" class="headerlink" title="1. 研究目标"></a>1. 研究目标</h2><p>本文提出了一种基于视觉诱发电位编码调制(c-VEP)的高速脑机接口。32个目标刺激由时移二进制伪随机序列调制。采用基于典型相关分析(CCA)的多通道识别方法进行目标识别。</p><h2 id="2-研究背景及问题陈述"><a href="#2-研究背景及问题陈述" class="headerlink" title="2. 研究背景及问题陈述"></a>2. 研究背景及问题陈述</h2><p>基于视觉诱发电位(VEP)的脑机接口(BCI)因其用户训练少、使用方便、ITR高等优点而受到越来越多的关注。与其他类型的基于视觉诱发电位的脑梗死相比，c-VEP脑梗死具有许多优点，包括增加了目标数目(16个目标)和更高的信噪比(92.8士14.1bitmin−1）</p><h2 id="3-研究方法"><a href="#3-研究方法" class="headerlink" title="3. 研究方法"></a>3. 研究方法</h2><h3 id="3-1-系统配置"><a href="#3-1-系统配置" class="headerlink" title="3.1 系统配置"></a>3.1 系统配置</h3><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416110149.png" alt="image-20210416102210407"></p><p>图1.c-VEP脑机接口的框图</p><p>采用亮暗交替的的刺激，二进制序列可以用作调制序列。在二进制序列中，“亮”和“暗”分别表示为“1”和“0”。</p><h3 id="3-2目标识别"><a href="#3-2目标识别" class="headerlink" title="3.2目标识别"></a>3.2目标识别</h3><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416111208.png" alt="image-20210416111208471"></p><p>图2。(A)基于c-VEP的脑机接口的目标排列。这32个目标以4×8( 屏幕中央的灰色区域)的形式分布，周围环绕着28个互补的闪光灯(白色背景)，这32个目标被28个互补的闪光灯(白色背景)包围着。目标上的数字表示目标的索引。互补的非目标与具有相同数字的目标同步。(B)一个刺激周期内32个靶点的调制序列。所有靶点同时激活，刺激周期不断重复。在两个连续的目标之间有两帧的时间间隔。</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416145958.png" alt="image-20210416145958634"></p><p>图3获得T0的刺激序列，通过对T0序列循环移位来获得所有刺激模块的信号</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416112115.png" alt="image-20210416112115532"></p><p>图4.目标识别的示例。在凝视目标T21期间记录要识别的数据，并且红星指示识别结果（相关系数最大）。</p><p>在获得所有目标的模板后，可以使用模板匹配方法进行目标识别。图4显示了模板匹配过程的框架。目标识别过程的步骤如下。</p><p>（1）在训练阶段，用户需要专注于参考目标。在我们的实验中，参考目标是目标T20。N个刺激周期内的脑电数据采集为xn(T)，n=1，2，…，N。</p><p>（2）参考模板MR(T)是通过在k个周期上求平均来获得的。在我们的实验中，参考模板是T20的模板，即$M_{20}$(T)：</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416154001.png" alt="image-20210416154001462"></p><p>(3)所有目标的模板都是通过移动参考模板得到的：<img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416154034.png" alt="image-20210416154034628"></p><p>其中$τ_k−τ_{20}$表示目标k和参考目标$T_{20}$之间的时间滞后。</p><p>(4)对于一段脑电数据x(t)，x(t)和模板$M_k(t)$之间的相关系数$ρ_k$被计算为</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416154220.png" alt="image-20210416154220328"></p><p>&lt;x,y&gt;表示x和y的乘积   </p><p>（5）通过选择相关系数最大的目标来识别固定目标。</p><p>通过VC++开发的在线分析程序进行目标识别</p><h3 id="3-3-多通道处理"><a href="#3-3-多通道处理" class="headerlink" title="3.3 多通道处理"></a>3.3 多通道处理</h3><p>以前采用穷举法，现在采用CCA分析</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416155837.png" alt="image-20210416155837878"></p><p>在实际应用中，我们采用Wx作为空间滤波系数进行在线数据处理。在我们的系统中，我们选择了枕区的9个电极(O1、Oz、O2、P3、Pz、P4、PO7、POZ和PO8)。</p><h2 id="4-评估，实验"><a href="#4-评估，实验" class="headerlink" title="4. 评估，实验"></a>4. 评估，实验</h2><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420101342.png" alt="image-20210420101342183"><br>图5.等效邻居原理的图解。(A)蓝色方框标记两个目标(T9和T30)，红色虚线方框表示两个目标的八个邻居。(B)邻居和目标之间的时间滞后(符号‘+’表示‘领先’，符号‘−’表示‘落后’)。例如，T9的左侧邻居是T8，其时间延迟为τ，即T9。所以左边邻居的时间滞后是+$τ_s$。</p><p>分别对16个靶和32个靶的两个系统进行了测试。五名视力正常或矫正正常的健康成年人在知情同意后参加了实验。他们是从有脑机接口实验经验的受试者中随机挑选出来的。对于每个系统，实验分为训练阶段和测试阶段。在训练阶段，受试者被要求专注于参考目标大约200个刺激期。训练阶段的数据被用于离线分析，以计算空间滤波器权重和供在线使用的参考模板。在测试阶段，每个受试者被要求输入64个字符的序列。使用在线准确率和相应的ITR来评估系统性能。在ITR的计算中，每个选择的时间成本为2.1s(包括两个刺激期，一个用于数据采集，另一个用于目标识别、反馈呈现和注视转移)。</p><p>来自我们先前研究的一个涉及12个受试者的数据集被用来测试多通道方法的性能[5]。在16个目标c-VEP脑机接口的训练阶段，测量了47个位于顶枕叶皮质上的脑电信号。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420100823.png" alt="image-20210420100815520"></p><p>表1比较了每个对象的最优双极方法和多通道方法的训练精度。在10%的显著性水平上，多通道方法的平均训练准确率显著高于最优双极方法(平均：95%对98%，p=0.06)。</p><p>表2列出了两个c-VEP脑机接口系统的测试结果。虽然32靶系统的在线准确率低于16靶系统(85±5%，92±3%，p=0.04)，但32靶系统的ITR优于16靶系统(108±12.0bits$min^{−1}$，96±6.3bits$min^{−1}$，p=0.08)。对于单个受试者，在32个靶点的系统中，最大ITR值为123bits$min^{−1}$。</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210420102832.png" alt="image-20210420102832757"></p><p>如表2所示，32个目标系统的平均ITR值明显高于16个目标系统(108bit最小−1与96位最小−1)。对于受试者s13、s14和s17，增量约为20位最小−1。然而，其他两个受试者在两个系统之间没有明显差异(分别为93位最小−1与96位最小−1和104bits$min^{−1}$与96bits$min^{−1}$，s15和s16分别为96bits$min^{−1}$和96bits$min^{−1}$)。当使用更多目标时，两个受试者的在线准确率显著下降(在16个目标系统中分别为91%和95%，而在32个目标系统中分别为80%)。精确度的降低可能是由于模板的非锐化自相关功能造成的。对于32个目标系统和16个目标系统，两个连续目标之间的时间间隔分别为2帧(33.3ms)和4帧(66.7ms)。因此，当模板的自相关函数不够尖锐时，对于较短的时间滞后，目标可能更容易被误识别</p><h2 id="6-笔记"><a href="#6-笔记" class="headerlink" title="6. 笔记"></a>6. 笔记</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
    <summary type="html">一种基于编码调制VEP的高速脑机接口</summary>
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="CCA" scheme="http://example.com/tags/CCA/"/>
    
    <category term="c-VEP" scheme="http://example.com/tags/c-VEP/"/>
    
  </entry>
  
  <entry>
    <title>Frequency Recognition Based on Canonical Correlation Analysis for SSVEP-Based BCIs</title>
    <link href="http://example.com/2021/04/14/%E5%9F%BA%E4%BA%8E%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E4%BA%8ESSVEP%E7%9A%84BCI%E9%A2%91%E7%8E%87%E8%AF%86%E5%88%AB/"/>
    <id>http://example.com/2021/04/14/%E5%9F%BA%E4%BA%8E%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E4%BA%8ESSVEP%E7%9A%84BCI%E9%A2%91%E7%8E%87%E8%AF%86%E5%88%AB/</id>
    <published>2021-04-14T04:43:42.247Z</published>
    <updated>2021-04-20T02:31:49.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-总结"><a href="#0-总结" class="headerlink" title="0. 总结"></a>0. 总结</h2><p>写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。注：写文章summary切记需要通过自己的思考，用自己的语言描述。忌讳直接Ctrl + c原文。</p><h2 id="1-研究目标"><a href="#1-研究目标" class="headerlink" title="1. 研究目标"></a>1. 研究目标</h2><p>采用典型相关分析（Canonical correlation analysis，CCA）对脑电中稳态视觉诱发电位（steady-state visual evoked potentials，SSVEP）进行频率分析。</p><h2 id="2-研究背景及问题陈述"><a href="#2-研究背景及问题陈述" class="headerlink" title="2. 研究背景及问题陈述"></a>2. 研究背景及问题陈述</h2><p>在SSVEP的BCI中使用最广泛的频率检测方法是基于功率谱密度的分析（ power spectral density based analysis，PSDA），在时间窗口内从用户的EEG信号估计功率谱密度，并随后检测其峰值。将与该峰值对应的频率作为视觉刺激频率。周期图是一种非参数功率谱估计方法，可以直接从离散傅立叶变换(DFT)计算。因此，可以利用快速傅立叶变换(FFT)进行计算，计算量小。与参数功率谱估计方法相比，周期图不需要先验阶次选择步骤，易于实现。此外，当数据受到噪声污染时，周期图法已被证明比参数估计方法更稳健。</p><p>PSDA缺点：单通道易受噪声干扰。</p><p>因此，使用信道协方差信息的典型相关分析，用以提高信噪比（signal-to-noise ratio，SNR）。</p><h2 id="3-研究方法"><a href="#3-研究方法" class="headerlink" title="3. 研究方法"></a>3. 研究方法</h2><p>CCA是一种多变量统计方法，当有两组数据时使用，这两组数据可能有一些潜在的相关性。CCA将普通相关性扩展到两组变量[6]、[7]。首先，CCA为两个集合找到一对线性组合，称为规范变量，使得两个规范变量之间的相关性最大化。然后，它找到第二对，它与第一对规范变量不相关，但具有次高的相关性。</p><p>每个键以一定频率闪烁，构成频率编码矩阵（frequency-coded matrix），当受试者凝视其中一个键时，相应的SSVEP就会出现。</p><h2 id="4-评估，实验"><a href="#4-评估，实验" class="headerlink" title="4. 评估，实验"></a>4. 评估，实验</h2><p>实现方法：被试通过注视LED面板中特定频率闪烁的LED来执行操作指令，在受试者的脑电图中会诱发和观察到与闪烁LED的基频相似的SSVEP。</p><p>与PSDA进行对比，采用256点快速傅里叶变换。</p><p>采用交叉验证设计对两种方法进行评价。将样本数据集分为用于信道选择的训练集和用于测试频率识别性能的测试集。对于每个系统，从所有刺激频率中随机截取的30秒长的信号构成训练集。其余30秒长的信号组成了测试集。从这些测试集中随机选择900个长度为s的信号段(对于单个频率为100个)，并执行频率识别。分析重复了10次。研究了对识别率的影响。准确率定义为正确判断刺激频率的样本(信号段)的百分比。设为识别算法确定的频率，为样本的真实刺激频率。那么精确度可以表示为</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416110041.png" alt="image-20210414102959251"></p><p>采样率900</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416110049.png" alt="image-20210414103438716"></p><p>使用这两种方法对不同受试者的时间窗长度的准确度和标准偏差。实线和虚线分别代表CCA和PSDA方法的结果。结果表明，在不同的时间窗长度下，CCA方法对大多数受试者(受试者NTS除外)的识别率均高于PSDA方法。</p><p><img src="https://gitee.com/zyxaxx/warehouse/raw/master/img/20210416110104.png" alt="image-20210414103513265"></p><p>受试者的平均准确率和配对t检验结果。黑条和白条分别代表CCA方法和PSDA方法的平均值。配对t检验的意义用星号表示，其中*代表p&lt;0：05，**代表p&lt;0：01。结果表明，在大多数时间窗口长度上，CCA方法明显优于PSDA方法。</p><h2 id="6-笔记"><a href="#6-笔记" class="headerlink" title="6. 笔记"></a>6. 笔记</h2><p>CCA精度不算所有算法中最高的，但是计算速度较快，易于理解，可以用于在线分析。</p><p>本论文只分析了的最大CCA系数，因为它传递的信息最多。这在理想条件下是正确的。然而，真实的脑电信号可能会受到噪声的污染，或者可能具有不连续的相变。这些因素导致信息传播到不止一个系数上。并且对于人类视觉系统来说，本文假设为线性，实际可能为非线性。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
    <summary type="html">基于典型相关分析的基于SSVEP的BCI频率识别</summary>
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="CCA" scheme="http://example.com/tags/CCA/"/>
    
    <category term="SSVEP" scheme="http://example.com/tags/SSVEP/"/>
    
  </entry>
  
  <entry>
    <title>CCA算法原理</title>
    <link href="http://example.com/2021/04/14/CCA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/04/14/CCA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</id>
    <published>2021-04-14T01:53:29.457Z</published>
    <updated>2021-04-14T01:55:01.209Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_42374697/article/details/105964577?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242">CCA算法</a></p><p><a href="https://gaokao.hujiang.com/gy/shuxue/p242121/">协方差</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_42374697/article/details/105964577?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandin</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python小甲鱼第25课字典</title>
    <link href="http://example.com/2021/04/13/Python%E5%B0%8F%E7%94%B2%E9%B1%BC/Python%E5%B0%8F%E7%94%B2%E9%B1%BC%E7%AC%AC25%E8%AF%BE%E5%AD%97%E5%85%B8%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%E5%AD%97%E5%85%B8%E7%9A%84%E7%89%B9%E6%80%A7%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%BD%95%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2021/04/13/Python%E5%B0%8F%E7%94%B2%E9%B1%BC/Python%E5%B0%8F%E7%94%B2%E9%B1%BC%E7%AC%AC25%E8%AF%BE%E5%AD%97%E5%85%B8%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%E5%AD%97%E5%85%B8%E7%9A%84%E7%89%B9%E6%80%A7%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%BD%95%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-04-13T02:20:43.208Z</published>
    <updated>2021-04-13T02:38:32.174Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;|--- 欢迎进入通讯录程序 ---|&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;|--- 1:查询联系人资料 ---|&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;|--- 2:插入新的联系人 ---|&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;|--- 3:删除已有的联系人 ---|&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;|--- 4:查看所有通讯录 ---|&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;|--- 5:退出通讯录程序 ---|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">tongxunlu=<span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    shuru=<span class="built_in">input</span>(<span class="string">&quot;\n请输入相关数字编号：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> shuru.isdigit():</span><br><span class="line">        shuru=<span class="built_in">int</span>(shuru)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;抱歉，您的输入有误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> shuru== <span class="number">1</span>:</span><br><span class="line">        name=<span class="built_in">input</span>(<span class="string">&#x27;请输入联系人姓名:&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> tongxunlu:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;姓名\t手机号码&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(name+<span class="string">&#x27;\t&#x27;</span>+tongxunlu[name])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;输入有误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> shuru==<span class="number">2</span>:</span><br><span class="line">        name=<span class="built_in">input</span>(<span class="string">&#x27;请输入联系人姓名：&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> tongxunlu:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;您输入的姓名在通讯录中已存在--&gt;&gt;&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>((name+<span class="string">&#x27;:&#x27;</span>+tongxunlu[name]))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">input</span>(<span class="string">&#x27;是否需要修改用户资料(YES/NO):&#x27;</span>).upper()==<span class="string">&#x27;YES&#x27;</span>:</span><br><span class="line">                tongxunlu[name]=<span class="built_in">input</span>(<span class="string">&#x27;请输入用户联系电话：&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tongxunlu[name]=<span class="built_in">input</span>(<span class="string">&#x27;请输入用户联系电话：&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;添加联系人&#x27;</span>+name+<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> shuru==<span class="number">3</span>:</span><br><span class="line">        name=<span class="built_in">input</span>(<span class="string">&#x27;请输入联系人姓名：&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> tongxunlu:</span><br><span class="line">            <span class="keyword">del</span>(tongxunlu[name])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;您输入的联系人不存在&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> shuru==<span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;姓名\t手机号码&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> tongxunlu:</span><br><span class="line">            <span class="built_in">print</span>(tongxunlu)</span><br><span class="line">    <span class="keyword">if</span> shuru==<span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">——利用字典的特性编写一个通讯录程序</summary>
    
    
    
    
    <category term="Python学习" scheme="http://example.com/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/04/11/test/"/>
    <id>http://example.com/2021/04/11/test/</id>
    <published>2021-04-11T04:30:26.682Z</published>
    <updated>2021-04-20T02:30:17.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-总结"><a href="#0-总结" class="headerlink" title="0. 总结"></a>0. 总结</h2><p>写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。注：写文章summary切记需要通过自己的思考，用自己的语言描述。忌讳直接Ctrl + c原文。</p><h2 id="1-研究目标"><a href="#1-研究目标" class="headerlink" title="1. 研究目标"></a>1. 研究目标</h2><p><img src="test/image-20210414120832812.png" alt="image-20210414120832812"></p><h2 id="2-研究背景及问题陈述"><a href="#2-研究背景及问题陈述" class="headerlink" title="2. 研究背景及问题陈述"></a>2. 研究背景及问题陈述</h2><h2 id="3-研究方法"><a href="#3-研究方法" class="headerlink" title="3. 研究方法"></a>3. 研究方法</h2><h2 id="4-评估，实验"><a href="#4-评估，实验" class="headerlink" title="4. 评估，实验"></a>4. 评估，实验</h2><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><h2 id="6-笔记"><a href="#6-笔记" class="headerlink" title="6. 笔记"></a>6. 笔记</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-总结&quot;&gt;&lt;a href=&quot;#0-总结&quot; class=&quot;headerlink&quot; title=&quot;0. 总结&quot;&gt;&lt;/a&gt;0. 总结&lt;/h2&gt;&lt;p&gt;写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。注：写文章summary切记需要通过自己的思考，用自己</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
</feed>
